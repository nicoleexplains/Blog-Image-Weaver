import { GoogleGenAI, Type } from "@google/genai";

// Ensure the API key is available in the environment variables
if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Generates a list of image prompts from a given blog article.
 * @param articleText The text of the blog article.
 * @param existingPrompts Optional list of prompts that have already been generated to avoid duplicates.
 * @returns A promise that resolves to an array of strings (image prompts).
 */
export async function generatePromptsFromArticle(articleText: string, existingPrompts: string[] = []): Promise<string[]> {
  try {
    let promptText = `Here is a blog article:\n\n---\n${articleText}\n---\n\nPlease generate an array of 5 distinct and visually descriptive image prompts that capture the key themes and moments in this article.`;

    if (existingPrompts.length > 0) {
      promptText += `\n\nThe following prompts have already been generated. Please generate 5 NEW, DIFFERENT prompts that explore other aspects of the article or use different visual styles:\n${existingPrompts.map(p => `- ${p}`).join('\n')}`;
    }

    // Using gemini-2.5-flash for speed and reliability (fewer 429s than Pro)
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: promptText,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            prompts: {
              type: Type.ARRAY,
              description: "An array of 5 visually descriptive image prompts.",
              items: {
                type: Type.STRING,
                description: "A single, concise, and visually descriptive prompt."
              }
            }
          },
          required: ["prompts"],
        },
        // Updated instructions to explicitly avoid safety filter triggers like drugs and violence
        systemInstruction: "You are an expert art director. Your task is to read a blog article and generate a series of concise, visually descriptive prompts for an AI image generator. The prompts should capture the key themes, concepts, or scenes from the article. The style should be photorealistic and cinematic unless the article suggests otherwise. CRITICAL SAFETY INSTRUCTION: The image generation model has strict safety filters. Do not generate prompts that depict illegal drugs, drug paraphernalia, excessive violence, or explicit content. If the article discusses these topics, generate METAPHORICAL, SYMBOLIC, or ABSTRACT prompts that capture the mood or theme without depicting the restricted elements directly.",
      }
    });

    let jsonText = response.text || "{}";
    // Clean up any potential markdown formatting that might slip through
    jsonText = jsonText.replace(/```json/g, '').replace(/```/g, '').trim();
    
    const parsed = JSON.parse(jsonText);
    
    if (parsed && Array.isArray(parsed.prompts)) {
      return parsed.prompts;
    } else {
      console.error("Unexpected JSON structure:", parsed);
      throw new Error("Failed to parse prompts from the AI response.");
    }

  } catch (error) {
    console.error("Error generating prompts:", error);
    if (error instanceof SyntaxError) {
       throw new Error("Received malformed response from AI. Please try again.");
    }
    throw error;
  }
}

/**
 * Generates an image from a given prompt, with fallback strategy.
 * 1. Tries 'gemini-3-pro-image-preview' (Nano Banana Pro / High Quality).
 * 2. If 429 (Quota) or error, falls back to 'gemini-2.5-flash-image'.
 * @param prompt The text prompt to generate an image from.
 * @returns A promise that resolves to a base64-encoded image data URL.
 */
export async function generateImageFromPrompt(prompt: string): Promise<string> {
  // Strategy 1: Try Gemini 3 Pro Image (Nano Banana Pro)
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: {
        parts: [
          { text: `${prompt}, photorealistic, cinematic lighting, high detail` }
        ]
      },
      config: {
        imageConfig: {
          aspectRatio: "16:9",
          imageSize: "1K"
        }
      }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
         return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
    throw new Error("No image generated by Gemini 3 Pro.");
    
  } catch (primaryError: any) {
    console.warn("Gemini 3 Pro Image generation failed. Attempting fallback to Gemini 2.5 Flash Image.", primaryError);
    
    // Strategy 2: Fallback to Gemini 2.5 Flash Image (Standard Quality / Different Quota)
    try {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
          parts: [
            { text: `${prompt}, photorealistic, cinematic, 16:9 aspect ratio` }
          ]
        },
        config: {
          imageConfig: {
            aspectRatio: "16:9"
          }
        }
      });

      for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData) {
           return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
      }
      throw new Error("No image data found in Flash Image response.");

    } catch (flashError: any) {
      console.error("Fallback generation failed.", flashError);
      
      // Determine the most relevant error message to show the user
      let errorMessage = "Failed to generate image.";
      
      const combinedErrors = `${primaryError.message} ${flashError.message}`;

      if (combinedErrors.includes("safety")) {
        errorMessage = "Image generation blocked by safety filters. Please edit the prompt to be more abstract.";
      } else if (combinedErrors.includes("429") || combinedErrors.includes("quota")) {
        errorMessage = "Daily image generation quota exceeded. Please try again later.";
      } else {
        errorMessage = flashError.message || primaryError.message;
      }
      
      throw new Error(errorMessage);
    }
  }
}